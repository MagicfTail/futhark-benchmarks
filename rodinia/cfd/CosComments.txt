# cfd: Computational Fluid Dynamics Solver

########################################
# Problems not related to parallelism: #
########################################
    -- there is a malloc inside a loop, but still in the sequential part,
        i.e., uses up much more memory than needed. This is generated by
        double-buffering and obviously needs a fix!

    -- To run the OpenCL version I hoisted outside the loop by hand the recalcitrant
        allocation!

    -- A minor problem is that in the code below
            map(fn [f32,nelr] (f32 x) => replicate(nelr, x), ff_variable)
       the parallelism of replicate is not exploited, leading to a very expensive
       kernel (since nelr >> sizeof(ff_variable)==5).
       This is minor since this kernel is executed only once, hence the
       overhead gets amortized.

##############################
# Description of Parallelism #
##############################

I. Main Convergence Loop:

    loop (variables) =
      for i < iterations() do
        let step_factors = compute_step_factor(variables, areas) in
        let new_variables= variables in
        loop(new_variables) =
          for j < RK() do
            let fluxes = compute_flux(  elements_surrounding_elements, 
                                        normals, new_variables, ff_variable, 
                                        ff_flux_contribution_momentum_x, 
                                        ff_flux_contribution_momentum_y, 
                                        ff_flux_contribution_momentum_z, 
                                        ff_flux_contribution_density_energy )
            in  time_step(j, variables, step_factors, fluxes)
        in  new_variables
    in variables

I.a.) "compute_step_factor" is a map (no seq loop inside)
I.b.) "compute_flux" is a "map(fn [f32,5] (int i) => ...", 
        but with indirect access to the input array,
        to get the neighbors of the current element, which are processed
        in a sequential loop. This would not be possible to express in
        Accelerate, and for example, it would not be automatically optimized
        so that the global-memory writes (of the map) are coalesced!
I.c.) "time_step" is a simple "map(fn [f32,5] (int i) => ... ",
        no sequential loop inside.
        

#########################
# Approximate Runtimes: #
#########################

On dataset: fvcorr.domn.193K

Sequential Total Runtime Rodinia: 490.8 secs
Sequential Total Runtime Futhark: 507.7 secs

OpenCL Total Runtime Rodinia:  3.428 secs from which
    Device<->Host Transfer time: 0.00887299 sec
    Kernel time:                 3.41867    sec

OpenCL Total Runtime Futhark: 3.096 secs from which
    ~ 2.889 secs is the computational kernel, i.e., 
    the two-level loops containing kernel calls.


